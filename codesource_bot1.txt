
def get_password():
    # Function: get_password
    # ----------------------------
    # Handles the decision making logic concerning private key encryption and asking the user for their password.
    #
    # returns: the user's password
    
    settings_changed = False
    setnewpassword = False
    
    # Check to see if the user has a version of the settings file before private key encryption existed
    if 'ENCRYPTPRIVATEKEYS' not in settings:
        response = ""
        settings_changed = True
        while response != "y" and response != "n":
            print("\nWould you like to use a password to encrypt your private keys?")
            response = input("You will need to input this password each time AlphaBot is executed (y/n): ")
        
        if response == "y":
            settings['ENCRYPTPRIVATEKEYS'] = "true"
            setnewpassword = True
        else:
            settings['ENCRYPTPRIVATEKEYS'] = "false"
            
            # If the user wants to encrypt their private keys, but we don't have an encrypted private key recorded, we need to ask for a password
    elif settings['ENCRYPTPRIVATEKEYS'] == "true" and not settings['PRIVATEKEY'].startswith('aes:'):
        print("\nPlease create a password to encrypt your private keys.")
        setnewpassword = True
    
    # Set a new password when necessary
    if setnewpassword == True:
        settings_changed = True
        passwords_differ = True
        while passwords_differ:
            pwd = pwinput.pwinput(prompt="\nType your new password: ")
            pwd2 = pwinput.pwinput(prompt="\nType your new password again: ")
            
            if pwd != pwd2:
                print("Error, password mismatch. Try again.")
            else:
                passwords_differ = False
    
    # The user already has encrypted private keys. Accept a password so we can unencrypt them
    elif settings['ENCRYPTPRIVATEKEYS'] == "true":
        
        if command_line_args.password:
            pwd = command_line_args.password
        else:
            pwd = pwinput.pwinput(prompt="\nPlease specify the password to decrypt your keys: ")
    
    else:
        pwd = ""
    
    if not pwd.strip():
        print()
        print("X WARNING =-= WARNING =-= WARNING =-= WARNING =-= WARNING =-= WARNING=-= WARNING X")
        print("X       You are running AlphaBot without encrypting your private keys.          X")
        print("X     Private keys are stored on disk unencrypted and can be accessed by         X")
        print("X anyone with access to the file system, including the Systems/VPS administrator X")
        print("X       and anyone with physical access to the machine or hard drives.           X")
        print("X WARNING =-= WARNING =-= WARNING =-= WARNING =-= WARNING =-= WARNING=-= WARNING X")
        print()
    
    if settings_changed == True:
        save_settings(settings, pwd)
    
    return pwd


# RUGDOC CONTROL IMPLEMENTATION

# Rugdoc's answers interpretations
interpretations = {
    "UNKNOWN": (style.RED + 'The status of this token is unknown. '
                            '                           This is usually a system error but could also be a bad sign for the token. Be careful.'),
    "OK": (style.GREEN + 'RUGDOC API RESULT : OK \n'
                         '                           √ Honeypot tests passed. RugDoc program was able to buy and sell it successfully. This however does not guarantee that it is not a honeypot.'),
    "NO_PAIRS": (style.RED + 'RUGDOC API RESULT : NO_PAIRS \n'
                             '                           ⚠ Could not find any trading pair for this token on the default router and could thus not test it.'),
    "SEVERE_FEE": (style.RED + 'RUGDOC API RESULT : SEVERE_FEE \n'
                               '                           /!\ /!\ A severely high trading fee (over 50%) was detected when selling or buying this token.'),
    "HIGH_FEE": (style.YELLOW + 'RUGDOC API RESULT : HIGH_FEE \n'
                                '                           /!\ /!\ A high trading fee (Between 20% and 50%) was detected when selling or buying this token. Our system was however able to sell the token again.'),
    "MEDIUM_FEE": (style.YELLOW + 'RUGDOC API RESULT : MEDIUM_FEE \n'
                                  '                           /!\ A trading fee of over 10% but less then 20% was detected when selling or buying this token. Our system was however able to sell the token again.'),
    "APPROVE_FAILED": (style.RED + 'RUGDOC API RESULT : APPROVE_FAILED \n'
                                   '                           /!\ /!\ /!\ Failed to approve the token.\n This is very likely a honeypot.'),
    "SWAP_FAILED": (style.RED + 'RUGDOC API RESULT : SWAP_FAILED \n'
                                '                           /!\ /!\ /!\ Failed to sell the token. \n This is very likely a honeypot.'),
    "chain not found": (style.RED + 'RUGDOC API RESULT : chain not found \n'
                                    '                           /!\ Sorry, rugdoc API does not work on this chain... (it does not work on ETH, mainly) \n')
}


def save_settings(settings, pwd):
    if len(pwd) > 0:
        encrypted_settings = settings.copy()
        encrypted_settings['ALPHAWALLETPRIVATEKEY'] = 'aes:' + cryptocode.encrypt(settings['ALPHAWALLETPRIVATEKEY'], pwd)
        encrypted_settings['PRIVATEKEY'] = 'aes:' + cryptocode.encrypt(settings['PRIVATEKEY'], pwd)
        if settings['PRIVATEKEY2'] != 'null':
            encrypted_settings['PRIVATEKEY2'] = 'aes:' + cryptocode.encrypt(settings['PRIVATEKEY2'], pwd)
        if settings['PRIVATEKEY3'] != 'null':
            encrypted_settings['PRIVATEKEY3'] = 'aes:' + cryptocode.encrypt(settings['PRIVATEKEY3'], pwd)
        if settings['PRIVATEKEY4'] != 'null':
            encrypted_settings['PRIVATEKEY4'] = 'aes:' + cryptocode.encrypt(settings['PRIVATEKEY4'], pwd)
        if settings['PRIVATEKEY5'] != 'null':
            encrypted_settings['PRIVATEKEY5'] = 'aes:' + cryptocode.encrypt(settings['PRIVATEKEY5'], pwd)
    
    # TODO: MASSAGE OUTPUT - AlphaBot currently loads settings.json as a [0] element, so we need to massage our
    #                  settings.json output so that it's reasable. This should probably be fixed by us importing
    #                  the entire json file, instead of just the [0] element.
    
    print(timestamp(), "Writing settings to file.")
    
    if settings['ENCRYPTPRIVATEKEYS'] == "true":
        output_settings = encrypted_settings
    else:
        output_settings = settings
    
    with open(command_line_args.settings, 'w') as f:
        f.write("[\n")
        f.write(json.dumps(output_settings, indent=4))
        f.write("\n]\n")


def build_extended_base_configuration(token_dict):
    # Function: build_extended_base_configuration
    # ----------------------------
    # Check the user defined token list for the _STABLE_BASES and build configurations for each
    #
    # returns: an array of dictionaries containing the configuration build of the token
    #          that can be parsed and or added to the the token configuration for trading

    printt_debug("ENTER build_extended_base_configuration")
    
    
    new_token_set = []

    # Giving values for the native pair
    token_dict['_BUILT_BY_BOT'] = True
    token_dict['LIQUIDITYINNATIVETOKEN'] = "true"
    # Giving values for the stables pair
    for stable_token in settings['_STABLE_BASES']:
        new_token = token_dict.copy()
        
        # special condition if SELLPRICE = 99999 (if sell price is in %, at bot launch)
        # you keep 99999 instead of re-calculating it with base price, to make the price more beautiful on the screen
        if token_dict['_CALCULATED_SELLPRICEINBASE'] == 99999:
            new_token.update({
                'BUYAMOUNTINBASE': token_dict['BUYAMOUNTINBASE'] * settings['_STABLE_BASES'][stable_token]['multiplier'],
                "BUYPRICEINBASE": token_dict['BUYPRICEINBASE'] * settings['_STABLE_BASES'][stable_token]['multiplier'],
                "SELLPRICEINBASE": token_dict['_CALCULATED_SELLPRICEINBASE'],
                "STOPLOSSPRICEINBASE": token_dict['_CALCULATED_STOPLOSSPRICEINBASE'],
                "MINIMUM_LIQUIDITY_IN_DOLLARS": token_dict['MINIMUM_LIQUIDITY_IN_DOLLARS'],
                "USECUSTOMBASEPAIR": "true",
                "LIQUIDITYINNATIVETOKEN": "false",
                "BASESYMBOL": stable_token,
                "_BASE_PRICE": settings['_STABLE_BASES'][stable_token]['multiplier'],
                "BASEADDRESS": settings['_STABLE_BASES'][stable_token]['address'],
                "_PAIR_SYMBOL": token_dict['SYMBOL'] + '/' + stable_token,
                "_BUILT_BY_BOT": True
            })
        else:
            new_token.update({
                            'BUYAMOUNTINBASE': token_dict['BUYAMOUNTINBASE'] * settings['_STABLE_BASES'][stable_token]['multiplier'],
                            "BUYPRICEINBASE": token_dict['BUYPRICEINBASE'] * settings['_STABLE_BASES'][stable_token]['multiplier'],
                            "SELLPRICEINBASE": float(token_dict['_CALCULATED_SELLPRICEINBASE']) * float(settings['_STABLE_BASES'][stable_token]['multiplier']),
                            "STOPLOSSPRICEINBASE": float(token_dict['_CALCULATED_STOPLOSSPRICEINBASE']) * float(settings['_STABLE_BASES'][stable_token]['multiplier']),
                            "MINIMUM_LIQUIDITY_IN_DOLLARS": token_dict['MINIMUM_LIQUIDITY_IN_DOLLARS'],
                            "USECUSTOMBASEPAIR": "true",
                            "LIQUIDITYINNATIVETOKEN": "false",
                            "BASESYMBOL": stable_token,
                            "_BASE_PRICE": settings['_STABLE_BASES'][stable_token]['multiplier'],
                            "BASEADDRESS": settings['_STABLE_BASES'][stable_token]['address'],
                            "_PAIR_SYMBOL": token_dict['SYMBOL'] + '/' + stable_token,
                            "_BUILT_BY_BOT": True
                            })
        
        # If these keys have special character on them, they represent percentages and we shouldn't copy them.
        if not re.search('^(\d+\.){0,1}\d+(x|X|%)$', str(token_dict['SELLPRICEINBASE'])):
            new_token['SELLPRICEINBASE'] = float(token_dict['SELLPRICEINBASE']) * float(settings['_STABLE_BASES'][stable_token]['multiplier'])
        if not re.search('^(\d+\.){0,1}\d+(x|X|%)$', str(token_dict['STOPLOSSPRICEINBASE'])):
            new_token['STOPLOSSPRICEINBASE'] = float(token_dict['STOPLOSSPRICEINBASE']) * float(settings['_STABLE_BASES'][stable_token]['multiplier'])
            
        new_token_set.append(new_token)
        
    return new_token_set


def parse_wallet_settings(settings, pwd):
    # Function: load_wallet_settings
    # ----------------------------
    # Handles the process of deciding whether or not the user's private key needs to be decrypted
    # Accepts user input for new private keys and wallet addresses
    #
    # returns: none (exits on incorrect password)
    
    settings_changed = False
    
    # Check for limit wallet information
    if " " in settings['ALPHAWALLETADDRESS'] or settings['ALPHAWALLETADDRESS'] == "":
        settings_changed = True
        settings['ALPHAWALLETADDRESS'] = input("Please provide the wallet address where you have your ALPHA : ")
    
    # Check for limit wallet private key
    if " " in settings['ALPHAWALLETPRIVATEKEY'] or settings['ALPHAWALLETPRIVATEKEY'] == "":
        settings_changed = True
        settings['ALPHAWALLETPRIVATEKEY'] = input("Please provide the private key for the wallet where you have your ALPHA : ")
    
    # If the limit wallet private key is already set and encrypted, decrypt it
    elif settings['ALPHAWALLETPRIVATEKEY'].startswith('aes:'):
        printt("Decrypting limit wallet private key.")
        settings['ALPHAWALLETPRIVATEKEY'] = settings['ALPHAWALLETPRIVATEKEY'].replace('aes:', "", 1)
        settings['ALPHAWALLETPRIVATEKEY'] = cryptocode.decrypt(settings['ALPHAWALLETPRIVATEKEY'], pwd)
        
        if settings['ALPHAWALLETPRIVATEKEY'] == False:
            printt_err("ERROR: Your private key decryption password is incorrect")
            printt_err("Please re-launch the bot and try again")
            sleep(10)
            sys.exit()
    
    # Check for trading wallet information
    if " " in settings['WALLETADDRESS'] or settings['WALLETADDRESS'] == "":
        settings_changed = True
        settings['WALLETADDRESS'] = input("Please provide the wallet address for your trading wallet: ")
    
    # Check for trading wallet private key
    if " " in settings['PRIVATEKEY'] or settings['PRIVATEKEY'] == "":
        settings_changed = True
        settings['PRIVATEKEY'] = input("Please provide the private key for the wallet you want to trade with: ")
    
    # If the trading wallet private key is already set and encrypted, decrypt it
    elif settings['PRIVATEKEY'].startswith('aes:'):
        print(timestamp(), "Decrypting trading wallet private key.")
        settings['PRIVATEKEY'] = settings['PRIVATEKEY'].replace('aes:', "", 1)
        settings['PRIVATEKEY'] = cryptocode.decrypt(settings['PRIVATEKEY'], pwd)
    
    # add of 2nd wallet
    if settings['WALLETADDRESS2'] == 'no_utility' or settings['PRIVATEKEY2'].startswith('aes:'):
        stoptheprocess = 1
    else:
        decision = ""
        while decision != "y" and decision != "n":
            decision = input(style.BLUE + "\nWould you like to add a 2nd wallet to use MULTIPLEBUYS feature? (y/n): ")
        
        if decision == "y":
            print(style.RESET + " ")
            # Check for trading wallet information
            if " " in settings['WALLETADDRESS2'] or settings['WALLETADDRESS2'] == "null":
                settings_changed = True
                settings['WALLETADDRESS2'] = input("Please provide the 2nd trading wallet address: ")
            
            # Check for trading wallet private key
            if " " in settings['PRIVATEKEY2'] or settings['PRIVATEKEY2'] == "null":
                settings_changed = True
                settings['PRIVATEKEY2'] = input("Please provide the 2nd private key for the 2nd trading wallet: ")
            stoptheprocess = 0
        else:
            settings['WALLETADDRESS2'] = "no_utility"
            stoptheprocess = 1
    
    # add of 3nd wallet
    if stoptheprocess != 1:
        decision = ""
        while decision != "y" and decision != "n":
            decision = input(style.BLUE + "\nWould you like to a 3rd wallet to use MULTIPLEBUYS feature ? (y/n): ")
        
        if decision == "y":
            print(style.RESET + " ")
            # Check for trading wallet information
            if " " in settings['WALLETADDRESS3'] or settings['WALLETADDRESS3'] == "null":
                settings_changed = True
                settings['WALLETADDRESS3'] = input("Please provide the 3rd trading wallet address: ")
            
            # Check for trading wallet private key
            if " " in settings['PRIVATEKEY3'] or settings['PRIVATEKEY3'] == "null":
                settings_changed = True
                settings['PRIVATEKEY3'] = input("Please provide the 3rd private key for the 3rd trading wallet: ")
            stoptheprocess = 0
        else:
            stoptheprocess = 1
    
    # add of 4th wallet
    if stoptheprocess != 1:
        decision = ""
        while decision != "y" and decision != "n":
            decision = input(style.BLUE + "\nWould you like to a 4th wallet to use MULTIPLEBUYS feature ? (y/n): ")
        
        if decision == "y":
            print(style.RESET + " ")
            # Check for trading wallet information
            if " " in settings['WALLETADDRESS4'] or settings['WALLETADDRESS4'] == "null":
                settings_changed = True
                settings['WALLETADDRESS4'] = input("Please provide the 4th trading wallet address: ")
            
            # Check for trading wallet private key
            if " " in settings['PRIVATEKEY4'] or settings['PRIVATEKEY4'] == "null":
                settings_changed = True
                settings['PRIVATEKEY4'] = input("Please provide the 4th private key for the 4th trading wallet: ")
            stoptheprocess = 0
        else:
            stoptheprocess = 1
    
    # add of 5th wallet
    if stoptheprocess != 1:
        decision = ""
        while decision != "y" and decision != "n":
            decision = input(style.BLUE + "\nWould you like to a 5th wallet to use MULTIPLEBUYS feature ? (y/n): ")
        
        if decision == "y":
            print(style.RESET + " ")
            # Check for trading wallet information
            if " " in settings['WALLETADDRESS5'] or settings['WALLETADDRESS5'] == "null":
                settings_changed = True
                settings['WALLETADDRESS5'] = input("Please provide the 5th trading wallet address: ")
            
            # Check for trading wallet private key
            if " " in settings['PRIVATEKEY5'] or settings['PRIVATEKEY5'] == "null":
                settings_changed = True
                settings['PRIVATEKEY5'] = input("Please provide the 5th private key for the 5th trading wallet: ")
    
    if settings_changed == True:
        save_settings(settings, pwd)
    print(style.RESET + " ")


@lru_cache(maxsize=None)
def decimals(address):
    # Function: decimals
    # ----------------------------
    # calculate how many decimals this token has
    #
    # address - token contract
    #
    # returns: returns the number of tokens for this contract

    try:
        balanceContract = client.eth.contract(address=Web3.toChecksumAddress(address), abi=standardAbi)
        decimals = balanceContract.functions.decimals().call()
        DECIMALS = 10 ** decimals
    except ABIFunctionNotFound:
        DECIMALS = 10 ** 18
    except ValueError as ve:
        logging.exception(ve)
        print("Please check your SELLPRICE values. ERROR in checking decimals")
    return DECIMALS


def check_logs():
    print(timestamp(), "Quickly Checking Log Size")
    with open(file_name) as f:
        line_count = 0
        for line in f:
            line_count += 1
        if line_count > 300:
            with open(file_name, "r") as f:
                lines = f.readlines()
            
            with open(file_name, "w") as f:
                f.writelines(lines[20:])
    
    f.close()


def decode_key():
    printt_debug("ENTER decode_key")
    private_key = settings['ALPHAWALLETPRIVATEKEY']
    acct = client.eth.account.privateKeyToAccount(private_key)
    addr = acct.address
    return addr


def auth():
    my_provider2 = 'https://rpc-mainnet.kcc.network'
    client2 = Web3(Web3.HTTPProvider(my_provider2))
    print(timestamp(), "Connected to KCC, checking your ALPHA balance... =", client2.isConnected())
    address = Web3.toChecksumAddress("0x0490c1076552ed3c91876ead9f6a547b389e69d4")
    abi = standardAbi
    balanceContract = client2.eth.contract(address=address, abi=abi)
    decimals = balanceContract.functions.decimals().call()
    DECIMALS = 10 ** decimals
    
    # Exception for incorrect Key Input
    try:
        decode = decode_key()
    except Exception:
        printt_err("There is a problem with your private key: please check if it's correct. Don't enter your seed phrase!")
        sleep(10)
        sys.exit()
    
    wallet_address = Web3.toChecksumAddress(decode)
    balance = balanceContract.functions.balanceOf(wallet_address).call()
    true_balance = balance / DECIMALS
    printt("Current Tokens Staked = ", true_balance, write_to_log=False)
    return true_balance


def approve(address, amount):
    print(timestamp(), "Approving", address)
    
    eth_balance = Web3.fromWei(client.eth.getBalance(settings['WALLETADDRESS']), 'ether')
    
    if base_symbol == "ETH ":
        minimumbalance = 0.05
    else:
        minimumbalance = 0.01
    
    if eth_balance > minimumbalance:
        printt("Estimating Gas Cost Using Web3")
        # Estimates GAS price and use a +20% factor
        if settings['EXCHANGE'] == 'uniswaptestnet':
            # Special condition on uniswaptestnet to make GAS > Priority Gas
            gas = (((client.eth.gasPrice) / 1000000000)) + ((client.eth.gasPrice) / 1000000000) * (int(200) / 100)
            printt("Current Gas Price =", gas)
        else:
            gas = (((client.eth.gasPrice) / 1000000000)) + ((client.eth.gasPrice) / 1000000000) * (int(20) / 100)
            printt("Current Gas Price = ", gas)
            
        contract = client.eth.contract(address=Web3.toChecksumAddress(address), abi=standardAbi)
        transaction = contract.functions.approve(routerAddress, amount).buildTransaction({
            'gasPrice': Web3.toWei(gas, 'gwei'),
            'gas': 1000000,
            'from': Web3.toChecksumAddress(settings['WALLETADDRESS']),
            'nonce': client.eth.getTransactionCount(settings['WALLETADDRESS'])
        })
        signed_txn = client.eth.account.signTransaction(transaction, private_key=settings['PRIVATEKEY'])
        
        try:
            return client.eth.sendRawTransaction(signed_txn.rawTransaction)
        finally:
            printt("Transaction Hash = ", Web3.toHex(client.keccak(signed_txn.rawTransaction)), write_to_log=True)
            tx_hash = client.toHex(client.keccak(signed_txn.rawTransaction))
            return tx_hash
    else:
        printt_err("You have less than 0.05 ETH or 0.01 KCS/FTM/MATIC/etc. tokens in your wallet, bot needs more to cover fees : please top up your wallet and restart.")
        sleep(10)
        sys.exit()


def check_approval(token, address, allowance_to_compare_with, condition):
    printt_debug("ENTER check_approval()")
    printt("Checking Approval Status", address)
    contract = client.eth.contract(address=Web3.toChecksumAddress(address), abi=standardAbi)
    actual_allowance = contract.functions.allowance(Web3.toChecksumAddress(settings['WALLETADDRESS']), routerAddress).call()
    
    printt_debug("actual_allowance 1591          :", actual_allowance)
    printt_debug("allowance_to_compare_with 1592 :", allowance_to_compare_with)
    
    allowance_request = 115792089237316195423570985008687907853269984665640564039457584007913129639935
    
    if actual_allowance < allowance_to_compare_with or actual_allowance == 0:
        if settings["EXCHANGE"] == 'quickswap':
            if actual_allowance == 0:
                tx = approve(address, allowance_request)
                wait_for_tx(token, tx, address)
            
            else:
                print("Revert to Zero To change approval")
                tx = approve(address, 0)
                wait_for_tx(token, tx, address)
                tx = approve(address, allowance_request)
                wait_for_tx(token, tx, address)

        else:
            if condition == 'base_approve':
                printt_info("---------------------------------------------------------------------------------------------")
                printt_info("Your base token is not approved --> AlphaBot will now APPROVE it, or it won't be able to buy")
                printt_info("---------------------------------------------------------------------------------------------")
            elif condition == 'preapprove':
                printt_info("-----------------------------------------------------------------------------")
                printt_info("You have selected PREAPPROVE = true --> AlphaBot will now APPROVE this token")
                printt_info("-----------------------------------------------------------------------------")
            elif condition == 'txfail':
                printt_info("----------------------------------------------------------------------------------")
                printt_info("You have failed to sell tokens --> AlphaBot will chack if it needs to be APPROVED")
                printt_info("----------------------------------------------------------------------------------")
            else:
                printt_info("-------------------------------------")
                printt_info("AlphaBot will now APPROVE this token")
                printt_info("-------------------------------------")

            tx = approve(address, allowance_request)
            wait_for_tx(token, tx, address)
            printt_ok("---------------------------------------------------------")
            printt_ok("  Token is now approved : AlphaBot can sell this token", write_to_log=True)
            printt_ok("---------------------------------------------------------")
        
        return allowance_request
    
    else:
        printt_ok("Token is already approved --> AlphaBot can use this token ")
        return actual_allowance


def check_bnb_balance():
    balance = client.eth.getBalance(settings['WALLETADDRESS'])
    printt("Current Wallet Balance is :", Web3.fromWei(balance, 'ether'), base_symbol, write_to_log=True)
    return balance


def check_balance(address, symbol='UNKNOWN_TOKEN', display_quantity=True):
    # Function: check_balance
    # --------------------
    # check and display the number of tokens in the user's wallet
    #
    # address - the contract address of the token we're looking for
    # symbol  - the symbol of the token we're looking for
    # display_quantity - boolean to report on the number of tokens
    #
    # returns: the wallet's token balance
    
    printt_debug("ENTER: check_balance() for " + address)
    
    address = Web3.toChecksumAddress(address)
    DECIMALS = decimals(address)
    balanceContract = client.eth.contract(address=address, abi=standardAbi)
    
    balance = balanceContract.functions.balanceOf(settings['WALLETADDRESS']).call()
    if display_quantity == True:
        printt("Current Wallet Balance is: ", str(balance / DECIMALS), symbol, write_to_log=True)
    else:
        printt_debug("display_quantity=False --> Do not display balance")
    printt_debug("EXIT: check_balance()")
    return balance


@lru_cache(maxsize=None)
def fetch_pair(inToken, outToken, contract):
    printt_debug("ENTER fetch_pair")
    pair = contract.functions.getPair(inToken, outToken).call()
    printt_debug("Pair Address = ", pair)
    return pair


PAIR_HASH={}
def fetch_pair2(inToken, outToken, contract):
    printt_debug("ENTER fetch_pair2")
    pair=PAIR_HASH.get((inToken,outToken))
    if pair is None:
        pair = contract.functions.getPair(inToken, outToken).call()
        if pair != '0x0000000000000000000000000000000000000000':
            PAIR_HASH[(inToken,outToken)] = pair
    printt_debug("Pair Address = ", pair)
    return pair

@lru_cache(maxsize=None)
def getContractLP(pair_address):
    printt_debug("ENTER getContractLP")
    return client.eth.contract(address=pair_address, abi=lpAbi)


# We use cache to check price of Custom Base pair for price calculation. Price will be updated every 30s (ttl = 30)
@cached(cache=TTLCache(maxsize=128, ttl=30))
def getReserves_with_cache(pair_contract):
    return pair_contract.functions.getReserves().call()


def check_pool(inToken, outToken, LIQUIDITY_DECIMALS):
    # This function is placed to calculate Liquidity of a token
    printt_debug("ENTER check_pool")
    # be careful, we cannot put cache and use fetch_pair, because we need to detect when pair_address != 0x0000000000000000000000000000000000000000
    # pair_address = fetch_pair2(inToken, outToken, factoryContract) --> we don't do that until we're sure
    
    pair_address = factoryContract.functions.getPair(inToken, outToken).call()
    if pair_address == '0x0000000000000000000000000000000000000000':
        printt_debug("check_pool condition 1 quick exit")
        return 0
    
    pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
    
    reserves = pair_contract.functions.getReserves().call()

    # Tokens are ordered by the token contract address
    # The token contract address can be interpreted as a number
    # And the smallest one will be token0 internally
    
    ctnb1 = int(inToken, 16)
    ctnb2 = int(outToken, 16)
    
    if (ctnb1 > ctnb2):
        printt_debug("reserves[0] is for outToken:")
        pooled = reserves[0] / LIQUIDITY_DECIMALS
    else:
        printt_debug("reserves[0] is for inToken:")
        pooled = reserves[1] / LIQUIDITY_DECIMALS
    
    printt_debug("Debug reserves[0] :", reserves[0] / LIQUIDITY_DECIMALS)
    printt_debug("Debug reserves[1] :", reserves[1] / LIQUIDITY_DECIMALS)
    printt_debug("Debug check_pool pooled :", pooled, "in token:", outToken)
    
    return pooled


def check_rugdoc_api(token):
    
    global rugdoc_accepted_tokens
    
    printt_debug("ENTER check_rugdoc_api")
    
    if token['ADDRESS'] not in rugdoc_accepted_tokens:
        # Use Rugdoc API to check if token is a honeypot or not
        rugresponse = requests.get(
            'https://honeypot.api.rugdoc.io/api/honeypotStatus.js?address=' + token['ADDRESS'] + rugdocchain)
        # sending get request and saving the response as response object
    
        if rugresponse.status_code == 200:
            d = json.loads(rugresponse.content)
            for key, value in interpretations.items():
                if d["status"] in key:
                    honeypot_status = value
                    honeypot_code = key
                    printt(honeypot_status)
                    print(style.RESET + " ")
    
        else:
            printt_warn(
                "Sorry, Rugdoc's API does not work on this token (Rugdoc does not work on ETH chain for instance)")
    
        token['_RUGDOC_DECISION'] = ""
        while token['_RUGDOC_DECISION'] != "y" and token['_RUGDOC_DECISION'] != "n":
            printt("What is your decision?")
            token['_RUGDOC_DECISION'] = input("                           Would you like to snipe this token? (y/n): ")
    
        if token['_RUGDOC_DECISION'] == "y":
            rugdoc_accepted_tokens.append(token['ADDRESS'])
            printt_debug(rugdoc_accepted_tokens)
            print(style.RESET + " ")
            printt_ok("OK let's go!!")
        else:
            print(style.RESET + " ")
            printt("DISABLING", token['SYMBOL'])
            token['ENABLED'] = 'false'
            token['_QUOTE'] = 0


def wait_for_open_trade(token, inToken, outToken):
    printt_debug("ENTER wait_for_open_trade")
    
    printt(" ", write_to_log=False)
    printt("-----------------------------------------------------------------------------------------------------------------------------", write_to_log=True)
    printt("WAIT_FOR_OPEN_TRADE is enabled", write_to_log=True)
    printt("", write_to_log=True)

    if token['WAIT_FOR_OPEN_TRADE'] == 'true' or token['WAIT_FOR_OPEN_TRADE'] == 'true_after_buy_tx_failed':
        printt("It works with 2 ways:", write_to_log=True)
        printt("1/ Bot will scan mempool to detect Enable Trading functions", write_to_log=True)
        printt("2/ Bot will wait for price to move before making a BUY order", write_to_log=True)
        printt(" ", write_to_log=False)
        printt("---- Why those 2 ways ? ----", write_to_log=False)
        printt("Because we need to enter the specific function used by the team to enable trading", write_to_log=False)
        printt("And there are a LOT of ways to do that, so we cannot always detect it in the mempool", write_to_log=False)
        printt(" ", write_to_log=False)
        printt(" ", write_to_log=False)
        printt_err("---- BE CAREFUL ----", write_to_log=True)
        printt_err("to make WAIT_FOR_OPEN_TRADE work, you need to SNIPE ON THE SAME LIQUIDITY PAIR the was used by the devs:", write_to_log=True)
        printt(" ", write_to_log=True)
        printt("Explanation : if you try to snipe in BUSD and liquidity is in BNB, the price will move because of the divergence between BUSD and BNB", write_to_log=False)
        printt("--> if liquidity is in BNB or ETH, use LIQUIDITYINNATIVETOKEN = true and USECUSTOMBASEPAIR = false", write_to_log=False)
        printt(" ", write_to_log=False)
        printt("When you will have read all this message and understand how it works, enter the value 'true_no_message' or 'true_after_buy_tx_failed_no_message' in your WAIT_FOR_OPEN_TRADE setting", write_to_log=False)
        printt(" ", write_to_log=False)
        printt("------------------------------------------------------------------------------------------------------------------------------", write_to_log=True)

    if token['WAIT_FOR_OPEN_TRADE'] == 'mempool' or token['WAIT_FOR_OPEN_TRADE'] == 'mempool_after_buy_tx_failed':
        printt("It will scan the mempool to detect Enable Trading functions", write_to_log=True)
        printt("------------------------------------------------------------------------------------------------------------------------------", write_to_log=True)
    
    if token['WAIT_FOR_OPEN_TRADE'] == 'pinksale':
        printt("It will scan the mempool to detect Pinksale launch", write_to_log=True)
        printt("------------------------------------------------------------------------------------------------------------------------------", write_to_log=True)

    openTrade = False
    
    token['_PREVIOUS_QUOTE'] = check_price(inToken, outToken, token['USECUSTOMBASEPAIR'], token['LIQUIDITYINNATIVETOKEN'], int(token['_CONTRACT_DECIMALS']), int(token['_BASE_DECIMALS']))

    # If we look for Pinksale sales, we look into the Presale Address's transactions for 0x4bb278f3 methodID
    try:
        if token['WAIT_FOR_OPEN_TRADE'] == 'pinksale':
            tx_filter = client.eth.filter({"filter_params": "pending", "address": Web3.toChecksumAddress(token['PINKSALE_PRESALE_ADDRESS'])})
        else:
            tx_filter = client.eth.filter({"filter_params": "pending", "address": inToken})
    except Exception as e:
        printt_err("Mempool scan error... It can happen with Public nodes : upgrade to a private node. Restarting")

    if token['WAIT_FOR_OPEN_TRADE'] == 'pinksale':
        # Function: finalize() - check examples below
        list_of_methodId = ["0x4bb278f3"]
    else:
        list_of_methodId = ["0xc9567bf9", "0x8a8c523c", "0x0d295980", "0xbccce037", "0x4efac329", "0x7b9e987a", "0x6533e038", "0x8f70ccf7", "0xa6334231", "0x48dfea0a", "0xc818c280", "0xade87098", "0x0099d386", "0xfb201b1d", "0x293230b8", "0x68c5111a", "0xc49b9a80", "0xc00f04d1", "0xcd2a11be", "0xa0ac5e19", "0x1d97b7cd", "0xf275f64b", "0x5e83ae76", "0x82aa7c68"]

    while openTrade == False:
    
        if token['WAIT_FOR_OPEN_TRADE'] == 'true' or token['WAIT_FOR_OPEN_TRADE'] == 'true_no_message' or token['WAIT_FOR_OPEN_TRADE'] == 'true_after_buy_tx_failed' or token['WAIT_FOR_OPEN_TRADE'] == 'true_after_buy_tx_failed_no_message':
            pprice = check_price(inToken, outToken, token['USECUSTOMBASEPAIR'], token['LIQUIDITYINNATIVETOKEN'], int(token['_CONTRACT_DECIMALS']), int(token['_BASE_DECIMALS']))
    
            if pprice != float(token['_PREVIOUS_QUOTE']):
                token['_TRADING_IS_ON'] = True
                printt_ok("Token price:", pprice, "--> IT HAS MOVED :)", write_to_log=True)
                printt_ok("PRICE HAS MOVED --> trading is enabled --> Bot will buy", write_to_log=True)
                break

            printt("Token price:", pprice)
        
        try:
            for tx_event in tx_filter.get_new_entries():

                txHash = tx_event['transactionHash']
                txHashDetails = client.eth.get_transaction(txHash)
                # printt_debug(txHashDetails)
                txFunction = txHashDetails.input[:10]
                if txFunction.lower() in list_of_methodId:
                    openTrade = True
                    token['_GAS_IS_CALCULATED'] = True
                    token['_GAS_TO_USE'] = int(txHashDetails.gasPrice) / 1000000000
                    printt_ok("OPEN TRADE FUNCTION DETECTED --> Trading is enabled --> Bot will buy", write_to_log=True)
                    printt_ok("MethodID: ", txFunction, " Block: ", tx_event['blockNumber'], " Found Signal", "in txHash:", txHash.hex(), write_to_log=True)
                    printt_ok("GAS will be the same as liquidity adding event. GAS=", token['_GAS_TO_USE'])
                    break
                else:
                    printt("Found something in mempool - MethodID: ", txFunction, " Block: ", tx_event['blockNumber'])
        except Exception as e:
            printt_err("Mempool scan error... It can happen with Public node : upgrade to a private node. Restarting")
            continue
            
            
    
    
def get_tokens_purchased(tx_hash):
    # Function: get_tokens_purchased
    # ----------------------------
    # provides the number of tokens purchased in a transaction
    #
    # tx_hash = the transaction hash
    #
    # returns: number of tokens purchased
    
    # Get transaction object
    tx = client.eth.get_transaction(tx_hash)
    contract = client.eth.contract(address=tx["to"], abi=lpAbi)
    
    # decode input data using contract object's decode_function_input() method
    func_obj, func_params = contract.decode_function_input(tx["input"])
    print(func_params)
    exit(0)

def build_sell_conditions(token_dict, condition, show_message):
    # Function: build_sell_conditions
    # ----------------------------
    # This function is designed to be called anytime sell conditions need to be adjusted for a token
    #
    # buy - provides the opportunity to specify a buy price, otherwise token_dict['_COST_PER_TOKEN'] is used
    # sell - provides the opportunity to specify a buy price, otherwise token_dict['SELLPRICEINBASE'] is used
    # stop - provides the opportunity to specify a buy price, otherwise token_dict['STOPLOSSPRICEINBASE'] is used

    printt_debug("ENTER build_sell_conditions() with", condition, "parameter")
    
    sell = token_dict['SELLPRICEINBASE']
    stop = token_dict['STOPLOSSPRICEINBASE']

    # Calculates cost per token

    if float(token_dict['_TOKEN_BALANCE']) > 0:
        if token_dict['KIND_OF_SWAP'] == 'base':
            token_dict['_COST_PER_TOKEN'] = float(token_dict['BUYAMOUNTINBASE']) / float((token_dict['_TOKEN_BALANCE'] - token_dict['_PREVIOUS_TOKEN_BALANCE']))
        elif token_dict['KIND_OF_SWAP'] == 'tokens':
            token_dict['_COST_PER_TOKEN'] = float(token_dict['_BASE_USED_FOR_TX']) / float(token_dict['BUYAMOUNTINTOKEN'])
        else:
            printt_err("Wrong value in KIND_OF_SWAP parameter")

    # Check to see if the SELLPRICEINBASE is a percentage of the purchase
    if re.search('^(\d+\.){0,1}\d+%$', str(sell)):
        sell = sell.replace("%","")
        if condition == 'before_buy':
            if show_message == "show_message":
                printt_err("--------------------------------------------------------------------------------------------------")
                printt_err("    DO NOT CLOSE THE BOT after BUY order is placed, or your calculated SELLPRICE will be lost!")
                printt_err("--------------------------------------------------------------------------------------------------")
                printt("")
                printt_info(token_dict['SYMBOL'],": since you have put a % in SELLPRICE, and the bot did not buy yet, we will set SELLPRICE = 99999 so the bot will not sell upon restart.")
            token_dict['_CALCULATED_SELLPRICEINBASE'] = 99999
        else:
            token_dict['_CALCULATED_SELLPRICEINBASE'] = token_dict['_COST_PER_TOKEN'] * (float(sell) / 100)
            printt_info("")
            printt_info(token_dict['SYMBOL'], " cost per token was: ", token_dict['_COST_PER_TOKEN'])
            printt_info("--> SELLPRICEINBASE = ", token_dict['SELLPRICEINBASE'],"*", token_dict['_COST_PER_TOKEN'], "= ", token_dict['_CALCULATED_SELLPRICEINBASE'])
    # Otherwise, don't adjust the sell price in base
    else:
        token_dict['_CALCULATED_SELLPRICEINBASE'] = sell
    # Check to see if the STOPLOSSPRICEINBASE is a percentage of the purchase
    if re.search('^(\d+\.){0,1}\d+%$', str(stop)):
        stop = stop.replace("%","")
        if condition == 'before_buy':
            if show_message == "show_message":
                printt_info("Since you have put a % in STOPLOSSPRICE, and the bot did not buy yet, we will set STOPLOSSPRICE = 0.")
            token_dict['_CALCULATED_STOPLOSSPRICEINBASE'] = 0
        else:
            token_dict['_CALCULATED_STOPLOSSPRICEINBASE'] = token_dict['_COST_PER_TOKEN'] * (float(stop) / 100)
            printt_info("--> STOPLOSSPRICEINBASE = ", token_dict['STOPLOSSPRICEINBASE'],"*", token_dict['_COST_PER_TOKEN'], "= ", token_dict['_CALCULATED_STOPLOSSPRICEINBASE'])
            printt_info("")

    # Otherwise, don't adjust the sell price in base
    else:
        token_dict['_CALCULATED_STOPLOSSPRICEINBASE'] = stop


    printt_debug("1111 token_dict['_CALCULATED_SELLPRICEINBASE']    :", token_dict['_CALCULATED_SELLPRICEINBASE'])
    printt_debug("1111 token_dict['_CALCULATED_STOPLOSSPRICEINBASE']:", token_dict['_CALCULATED_STOPLOSSPRICEINBASE'])
    printt_debug(token_dict)

    
    
def check_liquidity_amount(token, DECIMALS_OUT, DECIMALS_weth):
    # Function: check_liquidity_amount
    # ----------------------------
    # Tells if the liquidity of tokens purchased is enough for trading or not
    #
    # returns:
    #       - 0 if NOT OK for trading
    #       - 1 if OK for trading
    #
    #    There are 4 cases :
    #    1/ LIQUIDITYINNATIVETOKEN = true & USECUSTOMBASEPAIR = false --> we need to check liquidity in ETH / BNB...
    #    2/ LIQUIDITYINNATIVETOKEN = true & USECUSTOMBASEPAIR = true --> we need to check liquidity in ETH / BNB too
    #    3/ LIQUIDITYINNATIVETOKEN = false & USECUSTOMBASEPAIR = true --> we need to check liquidity in the CUSTOM Base Pair
    #    4/ LIQUIDITYINNATIVETOKEN = false & USECUSTOMBASEPAIR = false --> this case in handled line 1830 in the buy() function
    #
    
    printt_debug("ENTER: check_liquidity_amount()")
    
    inToken = Web3.toChecksumAddress(token['ADDRESS'])
    
    # Cases 1 and 2 above : we always use weth as LP pair to check liquidity
    if token["LIQUIDITYINNATIVETOKEN"] == 'true':
        printt_debug("check_liquidity_amount case 1")

        liquidity_amount = check_pool(inToken, weth, token['_LIQUIDITY_DECIMALS'])
        liquidity_amount_in_dollars = float(liquidity_amount) * float(token['_BASE_PRICE'])
        printt("Current", token['_PAIR_SYMBOL'], "Liquidity =", "{:.2f}".format(liquidity_amount_in_dollars), "$")
        printt("")
        
        if float(token['MINIMUM_LIQUIDITY_IN_DOLLARS']) <= float(liquidity_amount_in_dollars):
            printt_ok("MINIMUM_LIQUIDITY_IN_DOLLARS parameter =", int(token['MINIMUM_LIQUIDITY_IN_DOLLARS']), " --> Enough liquidity detected : let's go!")
            return 1
        
        # This position isn't looking good. Inform the user, disable the token and break out of this loop
        else:
            printt_warn("------------------------------------------------", write_to_log=True)
            printt_warn("NOT ENOUGH LIQUIDITY", write_to_log=True)
            printt_warn("", write_to_log=True)
            printt_warn("- You have set MINIMUM_LIQUIDITY_IN_DOLLARS  =", token['MINIMUM_LIQUIDITY_IN_DOLLARS'], "$", write_to_log=True)
            printt_warn("- Liquidity detected for", token['SYMBOL'], "=", "{:.2f}".format(liquidity_amount_in_dollars), "$", write_to_log=True)
            printt_warn("--> Bot will not buy and disable token", write_to_log=True)
            printt_warn("------------------------------------------------", write_to_log=True)
            token['ENABLED'] = 'false'
            token['_QUOTE'] = 0
            return 0
    
    # Case 3 above
    if token["LIQUIDITYINNATIVETOKEN"] == 'false' and token["USECUSTOMBASEPAIR"] == 'true':
        # This case is a little bit more complicated. We need to:
        # 1/ calculate Custom Base token price in ETH/BNB...
        # 2/ convert this Custom Base token price in $
        
        outToken = Web3.toChecksumAddress(token['BASEADDRESS'])
        printt_debug("check_liquidity_amount case 1")

        liquidity_amount = check_pool(inToken, outToken, token['_LIQUIDITY_DECIMALS'])
        
        # 1/ calculate Custom Base token price in ETH/BNB...
        # We could have used this also :
        #   custom_base_price_in_base = check_precise_price(outToken, weth, token['_WETH_DECIMALS'], token['_CONTRACT_DECIMALS'], token['_BASE_DECIMALS'])

        custom_base_price_in_base = calculate_custom_base_price(outToken, DECIMALS_OUT, DECIMALS_weth)

        # 2/ convert this Custom Base token price in $
        custom_base_price_in_dollars = float(custom_base_price_in_base) * float(token['_BASE_PRICE'])
        liquidity_amount_in_dollars = float(liquidity_amount) * float(custom_base_price_in_dollars)

        printt("Current", token['SYMBOL'], "Liquidity =", "{:.6f}".format(liquidity_amount_in_dollars), "$")
        
        if float(token['MINIMUM_LIQUIDITY_IN_DOLLARS']) <= float(liquidity_amount_in_dollars):
            printt_ok("MINIMUM_LIQUIDITY_IN_DOLLARS parameter =", int(token['MINIMUM_LIQUIDITY_IN_DOLLARS']), " --> Enough liquidity detected : let's go!")
            return 1
        
        # This position isn't looking good. Inform the user, disable the token and break out of this loop
        else:
            printt_warn("------------------------------------------------", write_to_log=True)
            printt_warn("NOT ENOUGH LIQUIDITY", write_to_log=True)
            printt_warn("", write_to_log=True)
            printt_warn("- You have set MINIMUM_LIQUIDITY_IN_DOLLARS  =", token['MINIMUM_LIQUIDITY_IN_DOLLARS'], "$", write_to_log=True)
            printt_warn("- Liquidity detected for", token['SYMBOL'], "=", "{:.2f}".format(liquidity_amount_in_dollars), "$", write_to_log=True)
            printt_warn("--> Bot will not buy and disable token", write_to_log=True)
            printt_warn("------------------------------------------------", write_to_log=True)
            token['ENABLED'] = 'false'
            token['_QUOTE'] = 0
            return 0


def check_price(inToken, outToken, custom, routing, DECIMALS_IN, DECIMALS_OUT):
    # CHECK GET RATE OF THE TOKEn
    printt_debug("ENTER check_price")
    stamp = timestamp()
    
    if custom == 'false':
        # USECUSTOMBASEPAIR = false
        base = base_symbol
    
    if routing == 'true':
        # LIQUIDITYINNATIVETOKEN = true
        if outToken != weth:
            # LIQUIDITYINNATIVETOKEN = true
            # USECUSTOMBASEPAIR = true and token put in BASEADDRESS is different from WBNB / WETH
            price_check = routerContract.functions.getAmountsOut(1 * DECIMALS_IN, [inToken, weth, outToken]).call()[-1]
            printt_debug("price_check condition 1: ", price_check)
            tokenPrice = price_check / DECIMALS_OUT
        else:
            # LIQUIDITYINNATIVETOKEN = true
            # USECUSTOMBASEPAIR = false
            # or USECUSTOMBASEPAIR = true and token put in BASEADDRESS is WBNB / WETH (because outToken == weth)
            price_check = routerContract.functions.getAmountsOut(1 * DECIMALS_IN, [inToken, weth]).call()[-1]
            printt_debug("price_check condition 2: ", price_check)
            tokenPrice = price_check / DECIMALS_OUT
    
    else:
        # LIQUIDITYINNATIVETOKEN = false
        if outToken != weth:
            # LIQUIDITYINNATIVETOKEN = false
            # USECUSTOMBASEPAIR = true and token put in BASEADDRESS is different from WBNB / WETH
            price_check = routerContract.functions.getAmountsOut(1 * DECIMALS_IN, [inToken, outToken]).call()[-1]
            printt_debug("price_check3: ", price_check)
            tokenPrice = price_check / DECIMALS_OUT
        else:
            # LIQUIDITYINNATIVETOKEN = false
            # USECUSTOMBASEPAIR = true and token put in BASEADDRESS is WBNB / WETH (because outToken == weth)
            price_check = routerContract.functions.getAmountsOut(1 * DECIMALS_IN, [inToken, weth]).call()[-1]
            printt_debug("price_check4: ", price_check)
            tokenPrice = price_check / DECIMALS_OUT
    
    printt_debug("tokenPrice: ", tokenPrice)
    return tokenPrice


ORDER_HASH = {}
def check_precise_price(inToken, outToken, DECIMALS_weth, DECIMALS_IN, DECIMALS_OUT):
    
    printt_debug("ENTER check_precise_price")

    if outToken != weth:
        printt_debug("ENTER check_precise_price condition 1")
        # First step : calculates the price of token in ETH/BNB
        pair_address = fetch_pair2(inToken, weth, factoryContract)
        pair_contract = getContractLP(pair_address)
        reserves = pair_contract.functions.getReserves().call()

        if ORDER_HASH.get(pair_address) is None:
            value0 = pair_contract.functions.token0().call()
            ORDER_HASH[pair_address] = (value0 == inToken)
        if not ORDER_HASH[pair_address]:
            tokenPrice1 = Decimal((reserves[0] / DECIMALS_weth) / (reserves[1] / DECIMALS_IN))
        else:
            tokenPrice1 = Decimal((reserves[1] / DECIMALS_weth) / (reserves[0] / DECIMALS_IN))
        printt_debug("tokenPrice1: ", tokenPrice1)
        
        # ------------------------------------------------------------------------
        # Second step : calculates the price of Custom Base pair in ETH/BNB
        pair_address = fetch_pair2(outToken, weth, factoryContract)
        pair_contract = getContractLP(pair_address)
        # We use cache to check price of Custom Base pair for price calculation. Price will be updated every 30s (ttl = 30)
        reserves = getReserves_with_cache(pair_contract)


        if ORDER_HASH.get(pair_address) is None:
            value0 = pair_contract.functions.token0().call()
            ORDER_HASH[pair_address] = (value0 == outToken)
        if not ORDER_HASH[pair_address]:
            tokenPrice2 = Decimal((reserves[0] / DECIMALS_weth) / (reserves[1] / DECIMALS_OUT))
        else:
            tokenPrice2 = Decimal((reserves[1] / DECIMALS_weth) / (reserves[0] / DECIMALS_OUT))
        printt_debug("tokenPrice2: ", tokenPrice2)
        
        # ------------------------------------------------------------------------
        # Third step : division
        #
        # Example with BUSD pair :
        #  - First step : token price = 0.000005 BNB
        #  - Second step : BUSD price = 1/500 BUSD
        #  --> Token price in BUSD = 0.00005 / (1/500) = 0.00005 * 500 = 0.00250 BUSD
        tokenPrice = tokenPrice1 / tokenPrice2
        
        
    else:
        printt_debug("ENTER check_precise_price condition 2")
        # USECUSTOMBASEPAIR = true and token put in BASEADDRESS is WBNB / WETH (because outToken == weth)
        # or USECUSTOMBASEPAIR = false
        pair_address = fetch_pair2(inToken, weth, factoryContract)
        printt_debug("check_precise_price pair_address:", pair_address)
        pair_contract = getContractLP(pair_address)
        reserves = pair_contract.functions.getReserves().call()
        
        if ORDER_HASH.get(pair_address) is None:
            value0 = pair_contract.functions.token0().call()
            ORDER_HASH[pair_address] = (value0 == inToken)
        if not ORDER_HASH[pair_address]:
            tokenPrice = Decimal((reserves[0] / DECIMALS_OUT) / (reserves[1] / DECIMALS_IN))
        else:
            tokenPrice = Decimal((reserves[1] / DECIMALS_OUT) / (reserves[0] / DECIMALS_IN))
        printt_debug("tokenPrice2: ", tokenPrice)
    
    return tokenPrice


def check_precise_price_new(inToken, outToken, DECIMALS_weth, DECIMALS_IN, DECIMALS_OUT):
    # This function is currently being reviewed and improved
    
    printt_debug("ENTER check_precise_price_new")
    pair_address = fetch_pair2(inToken, outToken, factoryContract)
    if pair_address != '0x0000000000000000000000000000000000000000':
        printt_debug("ENTER check_precise_price_new condition 0 direct pool LP")
        # First step : calculates the price of token in ETH/BNB
        
        pair_contract = getContractLP(pair_address)
        reserves = pair_contract.functions.getReserves().call()
        
        if ORDER_HASH.get(pair_address) is None:
            #value0 = pair_contract.functions.token0().call()
            ORDER_HASH[pair_address] = (inToken.lower() < outToken.lower())
        if not ORDER_HASH[pair_address]:
            tokenPrice1 = Decimal((reserves[0] / DECIMALS_OUT) / (reserves[1] / DECIMALS_IN))
        else:
            tokenPrice1 = Decimal((reserves[1] / DECIMALS_OUT) / (reserves[0] / DECIMALS_IN))
        return tokenPrice1
    
    if outToken != weth:
        printt_debug("ENTER check_precise_price_new condition 1")
        # First step : calculates the price of token in ETH/BNB
        
        pair_address = fetch_pair2(inToken, weth, factoryContract)
        pair_contract = getContractLP(pair_address)
        reserves = pair_contract.functions.getReserves().call()
        
        if ORDER_HASH.get(pair_address) is None:
            #value0 = pair_contract.functions.token0().call()
            ORDER_HASH[pair_address] = (inToken.lower() < weth.lower())
        if not ORDER_HASH[pair_address]:
            tokenPrice1 = Decimal((reserves[0] / DECIMALS_weth) / (reserves[1] / DECIMALS_IN))
        else:
            tokenPrice1 = Decimal((reserves[1] / DECIMALS_weth) / (reserves[0] / DECIMALS_IN))
        printt_debug("tokenPrice1: ", tokenPrice1)
        
        # ------------------------------------------------------------------------
        # Second step : calculates the price of Custom Base pair in ETH/BNB
        pair_address = fetch_pair2(outToken, weth, factoryContract)
        pair_contract = getContractLP(pair_address)
        reserves = pair_contract.functions.getReserves().call()

        if ORDER_HASH.get(pair_address) is None:
            #value0 = pair_contract.functions.token0().call()
            ORDER_HASH[pair_address] = (outToken.lower() < weth.lower())
        if not ORDER_HASH[pair_address]:
            tokenPrice2 = Decimal((reserves[0] / DECIMALS_weth) / (reserves[1] / DECIMALS_OUT))
        else:
            tokenPrice2 = Decimal((reserves[1] / DECIMALS_weth) / (reserves[0] / DECIMALS_OUT))
        printt_debug("tokenPrice2: ", tokenPrice2)
        
        # ------------------------------------------------------------------------
        # Third step : division
        # Example with BUSD pair :
        #  - First step : token price = 0.000005 BNB
        #  - Second step : BUSD price = 1/500 BUSD
        #  --> Token price in BUSD = 0.00005 / (1/500) = 0.00005 * 500 = 0.00250 BUSD
        tokenPrice = tokenPrice1 / tokenPrice2
    
    else:
        printt_debug("ENTER check_precise_price_new condition 2")
        # USECUSTOMBASEPAIR = true and token put in BASEADDRESS is WBNB / WETH (because outToken == weth)
        # or USECUSTOMBASEPAIR = false
        pair_address = fetch_pair2(inToken, weth, factoryContract)
        pair_contract = getContractLP(pair_address)
        reserves = pair_contract.functions.getReserves().call()
        
        if ORDER_HASH.get(pair_address) is None:
            value0 = pair_contract.functions.token0().call()
            ORDER_HASH[pair_address] = (value0 == inToken)
        if not ORDER_HASH[pair_address]:
            tokenPrice = Decimal((reserves[0] / DECIMALS_OUT) / (reserves[1] / DECIMALS_IN))
        else:
            tokenPrice = Decimal((reserves[1] / DECIMALS_OUT) / (reserves[0] / DECIMALS_IN))
        printt_debug("tokenPrice2: ", tokenPrice)
    
    return tokenPrice



@cached(cache=TTLCache(maxsize=128, ttl=30))
def calculate_base_price():
    # This function is placed to calculate price of base token (ETH / BNB / AVAX / FTM / KCS...)
    # Price will be updated every 30s

    printt_debug("ENTER: calculate_base_price")

    if base_symbol == "BNB" or base_symbol == "BNB ":
        DECIMALS_STABLES = 1000000000000000000
        DECIMALS_BNB = 1000000000000000000

        # BUSD
        pair_address = '0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16'
        pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
        reserves = pair_contract.functions.getReserves().call()
        basePrice = Decimal((reserves[1] / DECIMALS_STABLES) / (reserves[0] / DECIMALS_BNB))
        printt_debug("BNB PRICE: ", "{:.6f}".format(basePrice))

    elif base_symbol == "BNBt":
        DECIMALS_STABLES = 1000000000000000000
        DECIMALS_BNB = 1000000000000000000

        # Fixed price of 500$ for BNB on testnet
        basePrice = Decimal(500)
        printt_debug("BNBt PRICE: ", "{:.6f}".format(basePrice))

    elif base_symbol == "ETH ":
        DECIMALS_STABLES = 1000000
        DECIMALS_ETH = 1000000000000000000

        # USDT
        pair_address = '0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852'
        printt_debug("pair_address:", pair_address)
        pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
        reserves = pair_contract.functions.getReserves().call()
        basePrice = Decimal((reserves[1] / DECIMALS_STABLES) / (reserves[0] / DECIMALS_ETH))
        printt_debug("ETH PRICE: ", "{:.6f}".format(basePrice))
    
    elif base_symbol == "ETHt":
        DECIMALS_STABLES = 1000000
        DECIMALS_BNB = 1000000000000000000

        # Fixed price of 3500$ for ETH on testnet
        basePrice = Decimal(3500)
        printt_debug("BNBt PRICE: ", "{:.6f}".format(basePrice))

    elif base_symbol == "AVAX":
        DECIMALS_STABLES = 1000000
        DECIMALS_ETH = 1000000000000000000
    
        # USDT 0xc7198437980c041c805a1edcba50c1ce5db95118
        pair_address = '0xe28984e1EE8D431346D32BeC9Ec800Efb643eef4'
        printt_debug("pair_address:", pair_address)
        pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
        reserves = pair_contract.functions.getReserves().call()
        basePrice = Decimal((reserves[1] / DECIMALS_STABLES) / (reserves[0] / DECIMALS_ETH))
        printt_debug("AVAX PRICE: ", "{:.6f}".format(basePrice))

    elif base_symbol == "AVAXt":
        DECIMALS_STABLES = 1000000
        DECIMALS_BNB = 1000000000000000000

        # Fixed price of 80 for AVAX on testnet
        basePrice = Decimal(80)
        printt_debug("BNBt PRICE: ", "{:.6f}".format(basePrice))

    elif base_symbol == "FTM ":
        DECIMALS_STABLES = 1000000
        DECIMALS_ETH = 1000000000000000000
    
        # USDC 0x04068da6c83afcfa0e13ba15a6696662335d5b75
        pair_address = '0x2b4C76d0dc16BE1C31D4C1DC53bF9B45987Fc75c'

        printt_debug("pair_address:", pair_address)
        pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
        reserves = pair_contract.functions.getReserves().call()
        basePrice = Decimal((reserves[0] / DECIMALS_STABLES) / (reserves[1] / DECIMALS_ETH))
        printt_debug("FTM PRICE: ", "{:.6f}".format(basePrice))

    elif base_symbol == "KCS":
        DECIMALS_STABLES = 1000000000000000000
        DECIMALS_ETH = 1000000000000000000
    
        # USD 0x0039f574ee5cc39bdd162e9a88e3eb1f111baf48
    
        #address = Web3.toChecksumAddress('0x0039f574ee5cc39bdd162e9a88e3eb1f111baf48')
        #pair_address = fetch_pair2(address, weth, factoryContract)
    
        pair_address = '0x6c31e0F5c07b81A87120cc58c4dcc3fbafb00367'

        printt_debug("pair_address:", pair_address)
        pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
        reserves = pair_contract.functions.getReserves().call()
        basePrice = Decimal((reserves[0] / DECIMALS_STABLES) / (reserves[1] / DECIMALS_ETH))
        printt_debug("KCS PRICE: ", "{:.6f}".format(basePrice))
        
    elif base_symbol == "MATIC":
        DECIMALS_STABLES = 1000000
        DECIMALS_ETH = 1000000000000000000
    
        # USDT 0xc2132d05d31c914a87c6611c10748aeb04b58e8f
        # https://polygonscan.com/token/0xc2132d05d31c914a87c6611c10748aeb04b58e8f
        
        pair_address = '0x604229c960e5CACF2aaEAc8Be68Ac07BA9dF81c3'
        pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
        reserves = pair_contract.functions.getReserves().call()
        basePrice = Decimal((reserves[1] / DECIMALS_STABLES) / (reserves[0] / DECIMALS_ETH))
        printt_debug("MATIC PRICE: ", "{:.6f}".format(basePrice))

    elif base_symbol == "WONE":
        DECIMALS_STABLES = 1000000000000000000
        DECIMALS_ETH = 1000000000000000000
    
        # USDC1 0x985458e523db3d53125813ed68c274899e9dfab4
    
        pair_address = '0x6574026Db45bA8d49529145080489C3da71a82DF'
    
        printt_debug("pair_address:", pair_address)
        pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
        reserves = pair_contract.functions.getReserves().call()
        basePrice = Decimal((reserves[0] / DECIMALS_STABLES) / (reserves[1] / DECIMALS_ETH))
        printt_debug("WONE PRICE: ", "{:.6f}".format(basePrice))
    
    else:
        printt_err("Unknown chain... please add it to calculate_base_price")
        basePrice = 0
    
    for stable_token in settings['_STABLE_BASES']:
        settings['_STABLE_BASES'][stable_token]['multiplier'] = float(basePrice)
    printt_debug("basePrice:", basePrice)

    printt(base_symbol, "price:", "{:.2f}".format(basePrice), "$")
    
    return basePrice


@cached(cache=TTLCache(maxsize=128, ttl=30))
def calculate_custom_base_price(outToken, DECIMALS_OUT, DECIMALS_weth):
    # This function is placed to calculate price of custom base token in ETH/BNB...
    
    printt_debug("ENTER: calculate_custom_base_price")

    pair_address = fetch_pair2(outToken, weth, factoryContract)
    # pair_address = factoryContract.functions.getPair(outToken, weth).call()
    pair_contract = getContractLP(pair_address)
    # pair_contract = client.eth.contract(address=pair_address, abi=lpAbi)
    
    # We use cache to check price of Custom Base pair for price calculation. Price will be updated every 30s (ttl = 30)
    reserves = getReserves_with_cache(pair_contract)

    if ORDER_HASH.get(pair_address) is None:
        value0 = pair_contract.functions.token0().call()
        ORDER_HASH[pair_address] = (value0 == outToken)
    if not ORDER_HASH[pair_address]:
        custombasePrice = Decimal((reserves[0] / DECIMALS_weth) / (reserves[1] / DECIMALS_OUT))
    else:
        custombasePrice = Decimal((reserves[1] / DECIMALS_weth) / (reserves[0] / DECIMALS_OUT))
    
    printt_debug("custombasePrice: ", custombasePrice)

    return custombasePrice


def calculate_base_balance(token):
    # Function: calculate_base_balance
    # --------------------
    # calculate base balance
    # it is done before and after buy/sell so as the bot to be faster to make transactions
    #
    
    printt_debug("ENTER: calculate_base_balance()")

    # STEP 1 - Determine if wallet has minimum base balance
    # Bot will get your balance, and show an error if there is a problem with your node.
    if base_symbol == "ETH ":
        minimumbalance = 0.05
    else:
        minimumbalance = 0.03

    try:
        eth_balance = Web3.fromWei(client.eth.getBalance(settings['WALLETADDRESS']), 'ether')
    except Exception as e:
        printt_err("ERROR with your node : please check logs.", write_to_log=True)
        logger1.exception(e)
        sys.exit()

    if eth_balance < minimumbalance:
        printt_err("You have less than 0.05 ETH or 0.03 KCS/FTM/MATIC/etc. tokens in your wallet, bot needs more to cover fees : please top up your wallet and restart.")
        printt_err("We know it can seem a lot, but the smart contracts used by Exchanges have automatic controls of minimal balance.")
        sleep(10)
        exit(1)

    # STEP 2 - update token['_BASE_BALANCE'] or token['_CUSTOM_BASE_BALANCE']
    if token['USECUSTOMBASEPAIR'].lower() == 'false':
        token['_BASE_BALANCE'] = Web3.fromWei(check_bnb_balance(), 'ether')
        printt_debug("token['_BASE_BALANCE'] in calculate_base_balance:", token['_BASE_BALANCE'])
    else:
        address = Web3.toChecksumAddress(token['BASEADDRESS'])
        DECIMALS = decimals(address)
        balance_check = check_balance(token['BASEADDRESS'], token['BASESYMBOL'])
        token['_CUSTOM_BASE_BALANCE'] = balance_check / DECIMALS
        printt_debug("balance 2959 case2:", token['_CUSTOM_BASE_BALANCE'])


def calculate_gas(token):
    # Function: calculate_gas
    # --------------------
    # calculate gas to use based on user settings and blockchain
    #
    # token - one element of the tokens{} dictionary
    #
    # returns - 0
    #         - sets token['_GAS_TO_USE'] to gas that should be used for transaction
    
    printt_debug("ENTER: calculate_gas()")
    
    if int(token['GASLIMIT']) < 250000:
        printt_info(
            "Your GASLIMIT parameter is too low : AlphaBot has forced it to 300000 otherwise your transaction would fail for sure. We advise you to raise it to 1000000.")
        token['GASLIMIT'] = 300000
    
    if token['GAS'] == 'boost' or token['GAS'] == 'BOOST' or token['GAS'] == 'Boost':
        if base_symbol == "BNB" or base_symbol == "BNB ":
            gas_price = 10
        else:
            gas_check = client.eth.gasPrice
            gas_price = gas_check / 1000000000
        
        printt_info("")
        printt_info("Current Gas Price =", gas_price)
        token['_GAS_TO_USE'] = (gas_price * ((int(token['BOOSTPERCENT'])) / 100)) + gas_price
        printt_info("Transaction for", token['SYMBOL'], "will be created with gas =", token['_GAS_TO_USE'])
        printt_info("")
    else:
        token['_GAS_TO_USE'] = int(token['GAS'])
    
    printt_debug("EXIT: calculate_gas()")
    return 0


def make_the_buy(inToken, outToken, buynumber, pwd, amount, gas, gaslimit, gaspriority, routing, custom, slippage, DECIMALS):
    # Function: make_the_buy
    # --------------------
    # creates BUY order with the good condition
    #
    # returns - nothing
    #
    printt_debug("ENTER make_the_buy")
    
    # Choose proper wallet.
    if buynumber == 0:
        walletused = settings['WALLETADDRESS']
    if buynumber == 1:
        walletused = settings['WALLETADDRESS2']
    if buynumber == 2:
        walletused = settings['WALLETADDRESS3']
    if buynumber == 3:
        walletused = settings['WALLETADDRESS4']
    if buynumber == 4:
        walletused = settings['WALLETADDRESS5']

    if custom.lower() == 'false':
        # if USECUSTOMBASEPAIR = false
        
        if routing.lower() == 'false':
            # LIQUIDITYINNATIVETOKEN = false
            # USECUSTOMBASEPAIR = false
            printt_err("You have selected LIQUIDITYINNATIVETOKEN = false , so you must choose USECUSTOMBASEPAIR = true")
            printt_err("Please read the docs carefully")
            sleep(10)
            sys.exit()
        else:
            # LIQUIDITYINNATIVETOKEN = true
            # USECUSTOMBASEPAIR = false
            amount_out = routerContract.functions.getAmountsOut(amount, [weth, outToken]).call()[-1]
            if settings['UNLIMITEDSLIPPAGE'].lower() == 'true':
                amountOutMin = 0
            else:
                amountOutMin = int(amount_out * (1 - (slippage / 100)))

            deadline = int(time() + + 60)
            

            # THIS SECTION IS FOR MODIFIED CONTRACTS : EACH EXCHANGE NEEDS TO BE SPECIFIED
            # USECUSTOMBASEPAIR = false
            if modified == True:
                
                if settings["EXCHANGE"].lower() == 'alphaswap':
                    printt_debug("make_the_buy condition 1", write_to_log=True)
                    transaction = routerContract.functions.swapExactETHForTokens(
                        amountOutMin,
                        [weth, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'gasPrice': Web3.toWei(gas, 'gwei'),
                        'gas': gaslimit,
                        'value': amount,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused)
                    })
                
                elif settings["EXCHANGE"].lower() == 'pangolin' or settings["EXCHANGE"].lower() == 'traderjoe':
                    printt_debug("make_the_buy condition 2", write_to_log=True)
                    transaction = routerContract.functions.swapExactAVAXForTokens(
                        amountOutMin,
                        [weth, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'gasPrice': Web3.toWei(gas, 'gwei'),
                        'gas': gaslimit,
                        'value': amount,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused)
                    })

                elif settings["EXCHANGE"].lower() == 'bakeryswap':
                    printt_debug("make_the_buy condition 11", write_to_log=True)
                    transaction = routerContract.functions.swapExactBNBForTokens(
                        amountOutMin,
                        [weth, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'gasPrice': Web3.toWei(gas, 'gwei'),
                        'gas': gaslimit,
                        'value': amount,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused)
                    })

            
            else:
                # USECUSTOMBASEPAIR = false
                # This section is for exchange with Modified = false --> uniswap / pancakeswap / apeswap, etc.
                
                # Special condition on Uniswap, to implement EIP-1559

                if settings["EXCHANGE"].lower() == 'uniswap' or settings["EXCHANGE"].lower() == 'uniswaptestnet':
    
                    printt_debug("make_the_buy condition 3", write_to_log=True)
                    
                    transaction = routerContract.functions.swapExactETHForTokens(
                        amountOutMin,
                        [weth, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'maxFeePerGas': Web3.toWei(gas, 'gwei'),
                        'maxPriorityFeePerGas': Web3.toWei(gaspriority, 'gwei'),
                        'gas': gaslimit,
                        'value': amount,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused),
                        'type': "0x02"
                    })
                
                else:
                    # USECUSTOMBASEPAIR = false
                    # for all the rest of exchanges with Modified = false
                    
                    printt_debug("make_the_buy condition 4", write_to_log=True)
                    transaction = routerContract.functions.swapExactETHForTokens(
                        amountOutMin,
                        [weth, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'gasPrice': Web3.toWei(gas, 'gwei'),
                        'gas': gaslimit,
                        'value': amount,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused)
                    })
    
    else:
        # USECUSTOMBASEPAIR = true
        if inToken == weth:
            # USECUSTOMBASEPAIR = true
            # but user chose to put WETH or WBNB contract as CUSTOMBASEPAIR address
            amount_out = routerContract.functions.getAmountsOut(amount, [weth, outToken]).call()[-1]
            
            if settings['UNLIMITEDSLIPPAGE'].lower() == 'true':
                amountOutMin = 0
            else:
                amountOutMin = int(amount_out * (1 - (slippage / 100)))
            
            deadline = int(time() + + 60)
            
            if settings["EXCHANGE"].lower() == 'uniswap' or settings["EXCHANGE"].lower() == 'uniswaptestnet':
                # Special condition on Uniswap, to implement EIP-1559
                printt_debug("make_the_buy condition 5", write_to_log=True)
                transaction = routerContract.functions.swapExactTokensForTokens(
                    amount,
                    amountOutMin,
                    [weth, outToken],
                    Web3.toChecksumAddress(walletused),
                    deadline
                ).buildTransaction({
                    'maxFeePerGas': Web3.toWei(gas, 'gwei'),
                    'maxPriorityFeePerGas': Web3.toWei(gaspriority, 'gwei'),
                    'gas': gaslimit,
                    'from': Web3.toChecksumAddress(walletused),
                    'nonce': client.eth.getTransactionCount(walletused),
                    'type': "0x02"
                })
            
            else:
                printt_debug("make_the_buy condition 6", write_to_log=True)
                transaction = routerContract.functions.swapExactTokensForTokens(
                    amount,
                    amountOutMin,
                    [weth, outToken],
                    Web3.toChecksumAddress(walletused),
                    deadline
                ).buildTransaction({
                    'gasPrice': Web3.toWei(gas, 'gwei'),
                    'gas': gaslimit,
                    'from': Web3.toChecksumAddress(walletused),
                    'nonce': client.eth.getTransactionCount(walletused)
                })
        
        else:
            # LIQUIDITYINNATIVETOKEN = true
            # USECUSTOMBASEPAIR = true
            # Base Pair different from weth
            
            # We display a warning message if user tries to swap with too much money
            if (str(inToken).lower() == '0xe9e7cea3dedca5984780bafc599bd69add087d56'
                or str(inToken).lower() == '0x55d398326f99059ff775485246999027b3197955'
                or str(inToken).lower() == '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d'
                or str(inToken).lower() == '0xdac17f958d2ee523a2206206994597c13d831ec7'
                or str(inToken).lower() == '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48') and (int(amount) / 1000000000000000000) > 2999:
                printt_info("YOU ARE TRADING WITH A LARGE AMOUNT, ALWAYS REMEMBER TO ASSESS YOUR RISK!!!")
            
            if routing.lower() == 'true':
                amount_out = routerContract.functions.getAmountsOut(amount, [inToken, weth, outToken]).call()[-1]
                
                if settings['UNLIMITEDSLIPPAGE'].lower() == 'true':
                    amountOutMin = 100
                else:
                    amountOutMin = int(amount_out * (1 - (slippage / 100)))
                    
                deadline = int(time() + + 60)

                if settings["EXCHANGE"].lower() == 'uniswap' or settings["EXCHANGE"].lower() == 'uniswaptestnet':
                    # USECUSTOMBASEPAIR = true
                    # Base Pair different from weth
                    # LIQUIDITYINNATIVETOKEN = true
                    
                    # Special condition on Uniswap, to implement EIP-1559
                    printt_debug("make_the_buy condition 7", write_to_log=True)
                    transaction = routerContract.functions.swapExactTokensForTokens(
                        amount,
                        amountOutMin,
                        [inToken, weth, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'maxFeePerGas': Web3.toWei(gas, 'gwei'),
                        'maxPriorityFeePerGas': Web3.toWei(gaspriority, 'gwei'),
                        'gas': gaslimit,
                        'value': amount,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused),
                        'type': "0x02"
                    })
                
                else:
                    # USECUSTOMBASEPAIR = true
                    # Base Pair different from weth
                    # LIQUIDITYINNATIVETOKEN = true
                    # Exchange different from Uniswap
                    printt_debug("make_the_buy condition 8", write_to_log=True)
                    transaction = routerContract.functions.swapExactTokensForTokens(
                        amount,
                        amountOutMin,
                        [inToken, weth, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'gasPrice': Web3.toWei(gas, 'gwei'),
                        'gas': gaslimit,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused)
                    })
            
            else:
                # LIQUIDITYINNATIVETOKEN = false
                # USECUSTOMBASEPAIR = true
                # Base Pair different from weth
                
                # We display a warning message if user tries to swap with too much money
                if (str(inToken).lower() == '0xe9e7cea3dedca5984780bafc599bd69add087d56' or str(
                        inToken).lower() == '0x55d398326f99059ff775485246999027b3197955' or str(
                    inToken).lower() == '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d' or str(
                    inToken).lower() == '0xdac17f958d2ee523a2206206994597c13d831ec7' or str(
                    inToken).lower() == '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48') and (
                        int(amount) / DECIMALS) > 2999:
                    printt_info(
                        "YOU ARE TRADING WITH A LARGE AMOUNT, ALWAYS REMEMBER TO ASSESS YOUR RISK!!!")
                
                amount_out = routerContract.functions.getAmountsOut(amount, [inToken, outToken]).call()[-1]
                
                if settings['UNLIMITEDSLIPPAGE'].lower() == 'true':
                    amountOutMin = 100
                else:
                    amountOutMin = int(amount_out * (1 - (slippage / 100)))

                deadline = int(time() + + 60)
                
                if settings["EXCHANGE"].lower() == 'uniswap' or settings["EXCHANGE"].lower() == 'uniswaptestnet':
                    # LIQUIDITYINNATIVETOKEN = false
                    # USECUSTOMBASEPAIR = true
                    # Base Pair different from weth
                    # Special condition on Uniswap, to implement EIP-1559
                    printt_debug("make_the_buy condition 9", write_to_log=True)
                    transaction = routerContract.functions.swapExactTokensForTokens(
                        amount,
                        amountOutMin,
                        [inToken, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'maxFeePerGas': Web3.toWei(gas, 'gwei'),
                        'maxPriorityFeePerGas': Web3.toWei(gaspriority, 'gwei'),
                        'gas': gaslimit,
                        'value': amount,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused),
                        'type': "0x02"
                    })
                
                else:
                    # LIQUIDITYINNATIVETOKEN = false
                    # USECUSTOMBASEPAIR = true
                    # Base Pair different from weth
                    # Exchange different from Uniswap
                    printt_debug("make_the_buy condition 10", write_to_log=True)

                    transaction = routerContract.functions.swapExactTokensForTokens(
                        amount,
                        amountOutMin,
                        [inToken, outToken],
                        Web3.toChecksumAddress(walletused),
                        deadline
                    ).buildTransaction({
                        'gasPrice': Web3.toWei(gas, 'gwei'),
                        'gas': gaslimit,
                        'from': Web3.toChecksumAddress(walletused),
                        'nonce': client.eth.getTransactionCount(walletused)
                    })
        
    if buynumber == 0:
        # No need to decrypt PRIVATEKEY because it was already decrypted in parse_wallet_settings()
        # Leave it like that because it's also used in Pre-Approve
        #
        # settings['PRIVATEKEY'] = settings['PRIVATEKEY'].replace('aes:', "", 1)
        # settings['PRIVATEKEY'] = cryptocode.decrypt(settings['PRIVATEKEY'], pwd)
        signed_txn = client.eth.account.signTransaction(transaction, private_key=settings['PRIVATEKEY'])
    if buynumber == 1:
        settings['PRIVATEKEY2'] = settings['PRIVATEKEY2'].replace('aes:', "", 1)
        settings['PRIVATEKEY2'] = cryptocode.decrypt(settings['PRIVATEKEY2'], pwd)
        signed_txn = client.eth.account.signTransaction(transaction, private_key=settings['PRIVATEKEY2'])
    if buynumber == 2:
        settings['PRIVATEKEY3'] = settings['PRIVATEKEY3'].replace('aes:', "", 1)
        settings['PRIVATEKEY3'] = cryptocode.decrypt(settings['PRIVATEKEY3'], pwd)
        signed_txn = client.eth.account.signTransaction(transaction, private_key=settings['PRIVATEKEY3'])
    if buynumber == 3:
        settings['PRIVATEKEY4'] = settings['PRIVATEKEY4'].replace('aes:', "", 1)
        settings['PRIVATEKEY4'] = cryptocode.decrypt(settings['PRIVATEKEY4'], pwd)
        signed_txn = client.eth.account.signTransaction(transaction, private_key=settings['PRIVATEKEY4'])
    if buynumber == 4:
        settings['PRIVATEKEY5'] = settings['PRIVATEKEY5'].replace('aes:', "", 1)
        settings['PRIVATEKEY5'] = cryptocode.decrypt(settings['PRIVATEKEY5'], pwd)
        signed_txn = client.eth.account.signTransaction(transaction, private_key=settings['PRIVATEKEY5'])
    
    try:
        return client.eth.sendRawTransaction(signed_txn.rawTransaction)
    finally:
        printt("Transaction Hash = ", Web3.toHex(client.keccak(signed_txn.rawTransaction)), write_to_log=True)

        tx_hash = client.toHex(client.keccak(signed_txn.rawTransaction))
        return tx_hash

